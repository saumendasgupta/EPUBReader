

package com.sdg.DisplayManager;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.graphics.Paint;
import android.graphics.Typeface;

import com.sdg.EPUBparser.EPUBparser;
import com.sdg.linebreak.linebreak;

/*
 * To store the line break algorithms output 
 */
class DispMgrLineBreakInfo {
	/* to store the buffer */
	String msLbInBuffer;
	/* to hold line length */
	int miLbLen;
	/* to hold the language */
	String msLbLanguage;
	/* break points for generated by line break by algorithm */
	byte[] mbLbBreakpoints;
}

/*
 * To store the page display information
 */
class DispMgrReflow {
	/* to hold wher to start the line */
	int miRfLineStartX;
	/* to hold right margin value */
	int miRfRightMargin;
	/* to hold the x position for a line */
	int miRfLineX;
	/* to hold the font size */
	float mfRfFontSize;
	/* to hold font style */
	int miRfFontStyle;
	/* to hold font family */
	Typeface msRfFontFamily;
	/* to hold font weight */
	float mRfFontWeight;
	/* output data after reflow */
	byte[] mbBreakData;
}

/*
 * Holds the values related to book
 */
public class DispMgrBookInfo {
	EPUBparser epubparser = new EPUBparser();
	DispMgrUtility utl = new DispMgrUtility();
	DispMgrPageStyleInfo mDmPageStyleInfo = new DispMgrPageStyleInfo();

	/* conntent to be displayed */
	String msDmbDatabuffer;
	/* This will hold total no of chapter in book */
	long miDmbTotalChapter;
	/* Current dispalyed chapter no */
	int miDmbCurrentChapter;
	/* Current Page no */
	int miDmbPageNo;
	/* If one para expanded over two page , this variable will indiacate that */
	int miDmbLineBufferStatus;

	public int ISTOCFROMBOOKMARK = 0;
	/*
	 * If one para expanded over two pages,the second page should start from
	 * this line no
	 */
	int miDmbLineNo;
	/* The displayed book name */
	String msDmbBookName;
	/* to hols the book start */
	int miDmbBookStart;
	/* Status flag */
	int miDmbBookStatus;
	/* For page up navigation it will hold the uniqui xml id */
	String msDmbXmlLevl;
	/* hold the zoom level */
	String msDmbPreZoomXmlLevl;
	/* zoom indication flag */
	String msDmbZoomIndFlag;
	/* content of the entire line to be displayed */
	String msDmbLinebuffer;
	/* hold OPF file path */
	String msDmbOpfPath;
	float mfDmbZoomLevel;
	/***************************/
	/* This is used for proper styling */
	int miDmbPreContent; /* to be used like enum */
	/* Total no of line in the reflowed buffer */
	int miDmbLineCount;
	int miDmbDisplayLineCount;
	/* for next view start position */
	int miDmbViewXpos;
	int miDmbViewYpos;
	/* for current view height and width */
	int miDmbViewHeight;
	int miDmbViewWidth;
	
	
	int BypassgetnextField = 0;
    
	
	/*
	 * ADded fro the TOC operation
	 */
	// for faster operation of TOC
	public int mFasterTOc = 0;

	public static int SPACE = 0x20;
	/* Initialization of page flags for normal and thread operations */
	public int mObjDifFlag = 1;

	/*
	 * Initialize the EPUB parser components
	 */
	int mDisplayManagerInit(SQLiteDatabase db, int BookMark) {
		String sOPFFilePath = null;
		/* if book name is null */
		if (this.msDmbBookName == null) {
			return utl.DISPMGR_FAILURE;
		}
		/* Calling JNI for the container parser */
		epubparser.cprootfile = epubparser.EPUB_AL_ParseContainerFile(
				msDmbBookName, epubparser.cproot);
		/* cprootfile is null */
		if (epubparser.cprootfile == null) {
			return utl.DISPMGR_FAILURE;
		}
		// returns OPF file path
		sOPFFilePath = epubparser.CP_GetOpfPath(epubparser.cproot,
				epubparser.cprootfile);
		/* opf file path is null */
		if (sOPFFilePath == null) {
			return utl.DISPMGR_FAILURE;
		}
		/* JNI call for free the memory */
		epubparser.CP_Uninit();
		/* Calling JNI for the OPF parser */
		epubparser.amanifestelement = epubparser.EPUB_AL_ParseOPFFile(
				this.msDmbBookName, sOPFFilePath, epubparser.objMetadata);
		/* if manifest elenent is null */
		if (epubparser.amanifestelement == null) {
			return utl.DISPMGR_FAILURE;
		}
		/* Calling JNI for the Spine element parser */
		epubparser.aspineelement = epubparser.JNI_OPF_Init_Spine(sOPFFilePath,
				epubparser.objMetadata);
		/* Calling JNI for the Guide element parser */
		epubparser.aguideelement = epubparser.JNI_OPF_Init_Guide(sOPFFilePath,
				epubparser.objMetadata);
		// Returns total no of chapters in a book
		miDmbTotalChapter = epubparser
				.OPF_Get_No_of_Chapters(epubparser.objMetadata);
		/* Initialize the chapter number to initial chapter */
		this.miDmbCurrentChapter = 0;
		/* initialization of xml level */
		msDmbXmlLevl = null;
		/* initialization of pagee no */
		this.miDmbPageNo = 1;
		/* initialization of line no */
		this.miDmbLineNo = utl.DISPMGR_FIRSTLINE;
		/* initialization of buffer status */
		this.miDmbLineBufferStatus = utl.EBOOK_FALSE;
		/* initialization of book start */
		miDmbBookStart = utl.EBOOK_FALSE;
		/* initialization of pre content */
		this.miDmbPreContent = utl.XHTML_TAG_ELEMENT_COUNT;
		/* Deafult zoom level */
		this.mfDmbZoomLevel = 1;
		if (BookMark == 1) {

			// BOOK MARK Code Starts
			// Context c = null;

			//Display_Manager.TOCClicked = 1;
			Cursor PageCursor = db.rawQuery(
					"Select * From BookMarkTable Where BookName = '"
							+ Display_Manager.mBookPath + "';", null);
			PageCursor.moveToFirst();

			if (PageCursor.getCount() > 0) {
				this.ISTOCFROMBOOKMARK = 1;
				if (null != PageCursor.getString(PageCursor
						.getColumnIndex("XmlLevel"))) {
					/* clear the memory */
					epubparser.XHTML_Deinit();
					/* get the chapter number */
					this.miDmbCurrentChapter = PageCursor.getInt(2) - 1;

				}
				/* set line buffer status */
				this.miDmbLineBufferStatus = utl.EBOOK_FALSE;
				/* set book status */
				this.miDmbBookStatus = utl.EBOOK_TRUE;
				/* get page number */
				this.miDmbPageNo = PageCursor.getInt(1);
				/* set pre content */
				this.miDmbPreContent = utl.XHTML_TAG_ELEMENT_COUNT;
				/* set xmllevel */
				this.msDmbXmlLevl = PageCursor.getString(3);
				/* get line number */
				this.miDmbLineNo = PageCursor.getInt(4);
				/* get zoome level */
				this.mfDmbZoomLevel = PageCursor.getFloat(5);

				Display_Manager.TOCClicked = PageCursor.getInt(6);

				/* close the cursor */

				PageCursor.close();
			}

			// BOOK MARK Code Ends

		}
		return utl.DISPMGR_SUCCESS;
	}

	// Finction to get Nth Page information

	int mDisplayManagerGetNthPageInfor(SQLiteDatabase db, int pagenum,
			int CurrentChapter) {
		Cursor pageCursor = null;
		
		/*To FIX The Japane*/
		do{
			if(Display_Manager.TOCClicked != 1)
			{
				pageCursor = db.rawQuery("SELECT MAX(PageNo) FROM "
					+ DispMgrUtility.INDEX_TABLE + ";", null);
			}
			else
			{
				pageCursor = db.rawQuery("SELECT MAX(PageNo) FROM "
						+ DispMgrUtility.CURRENT_INDEX_TABLE +";", null);
			}
			pageCursor.moveToFirst();
			
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}while(pageCursor.getInt(0) < pagenum);
		
		
		
		
		
		/* get the page information to go back to previous page */
		try {
			Display_Manager.mSemaphore.acquire();

		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		/* set page flag for normal page operation */
		this.mObjDifFlag = Display_Manager.PAGE_NAVIGATION_START;
		if (Display_Manager.TOCClicked != 1) {
			/* fetch page information from index table */
			pageCursor = db.rawQuery("SELECT * FROM "
					+ DispMgrUtility.INDEX_TABLE + " WHERE PageNo = " + pagenum
					+ ";", null);
		} else {
			/*pageCursor = db.rawQuery("SELECT ChapterNo FROM "
					+ DispMgrUtility.PREVIOUS_INDEX_TABLE + ";", null);
			pageCursor.moveToFirst();
			if(pageCursor.getInt(0) == CurrentChapter)
			{
				pageCursor = db.rawQuery("SELECT * FROM "
						+ DispMgrUtility.PREVIOUS_INDEX_TABLE + " WHERE PageNo = " + pagenum
						+ ";", null);
			}
			else
			{*/
				pageCursor = db.rawQuery("SELECT * FROM "
						+ DispMgrUtility.CURRENT_INDEX_TABLE
						+ " WHERE PageNo = " + pagenum + ";", null);
			//}

		}
		/* move the cursor to first position */
		pageCursor.moveToFirst();
		/* if xmllevel not null */
		if (null != pageCursor.getString(pageCursor.getColumnIndex("XmlLevel"))) {
			/* clear the memory */
			epubparser.XHTML_Deinit();
			/* get the chapter number */
			this.miDmbCurrentChapter = pageCursor.getInt(1) - 1;
		}
		/* set line buffer status */
		this.miDmbLineBufferStatus = utl.EBOOK_FALSE;
		/* set book status */
		this.miDmbBookStatus = utl.EBOOK_TRUE;
		/* get page number */
		this.miDmbPageNo = pageCursor.getInt(0);
		/* set pre content */
		this.miDmbPreContent = utl.XHTML_TAG_ELEMENT_COUNT;
		/* set xmllevel */
		this.msDmbXmlLevl = pageCursor.getString(2);
		/* get line number */
		this.miDmbLineNo = pageCursor.getInt(3);
		/* get zoome level */
		this.mfDmbZoomLevel = pageCursor.getFloat(4);
		/* close the cursor */
		pageCursor.close();
		return 0;
	}

	int mDisplayManagerGetPageInfo(SQLiteDatabase db, int chapternum,
			String xmllev, int linenumber, int pageno) {
		/* get the page information to go back to previous page */

		Cursor pageCursor = null;

		/* fetch page information from index table For normal page operation */
		if (Display_Manager.TOCClicked != 1) {
			try {
				Display_Manager.mSemaphore.acquire();
				/* set page flag for normal page operation */
				this.mObjDifFlag = Display_Manager.PAGE_NAVIGATION_START;
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

			if (Display_Manager.mPageNumberIsNotcurroct == 1) {
				pageCursor = db.rawQuery("SELECT * FROM "
						+ DispMgrUtility.INDEX_TABLE + " WHERE ChapterNo <= "
						+ chapternum + ";", null);
				pageCursor.moveToFirst();
				int makcount = 0;
				while ((pageCursor.getCount() > makcount)
						&& ((!pageCursor.getString(2).equalsIgnoreCase(xmllev)) || pageCursor
								.getInt(3) != linenumber)) {
					pageCursor.moveToNext();
					makcount++;
				}
				pageCursor.moveToPrevious();
				pageCursor.moveToPrevious();
				Display_Manager.mFlagToCheckPageIsFromTOCtoIndexGeneration = 0;
				Display_Manager.mPageNumberIsNotcurroct = 0;
			}

			else {
				pageCursor = db.rawQuery("SELECT * FROM "
						+ DispMgrUtility.INDEX_TABLE + " WHERE PageNo = "
						+ pageno + ";", null);
				pageCursor.moveToFirst();
			}
		}

		else {
			while (true) {
				try {
					Display_Manager.mSemaphore.acquire();
					/* set page flag for normal page operation */
					this.mObjDifFlag = Display_Manager.PAGE_NAVIGATION_START;
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

				if (Display_Manager.mPageNumberIsNotcurroct == 1) {
					if (pageno == 1) {
						pageCursor = db.rawQuery(
								"SELECT MAX(PageNo),ChapterNo,XmlLevel,LineNo,ZoomLevel FROM "
										+ DispMgrUtility.CURRENT_INDEX_TABLE
										+ ";", null);

					}

					else {
						pageCursor = db.rawQuery("SELECT * FROM "
								+ DispMgrUtility.CURRENT_INDEX_TABLE + ";",
								null);
						pageCursor.moveToFirst();
						int makcount = 0;
						while ((pageCursor.getCount() > makcount)
								&& ((!pageCursor.getString(2).equalsIgnoreCase(
										xmllev)) || pageCursor.getInt(3) != linenumber)) {
							pageCursor.moveToNext();
							makcount++;
						}
						pageCursor.moveToPrevious();
						pageCursor.moveToPrevious();
						Display_Manager.mFlagToCheckPageIsFromTOCtoIndexGeneration = 0;
						Display_Manager.mPageNumberIsNotcurroct = 0;
						break;

					}

					Display_Manager.mPageNumberIsNotcurroct = 0;
					pageCursor.moveToFirst();
					break;

				} else {
					if (pageno == 1) {

						pageCursor = db.rawQuery("SELECT * FROM "
								+ DispMgrUtility.CURRENT_INDEX_TABLE
								+ " WHERE PageNo == " + (this.miDmbPageNo)
								+ ";", null);

					} else {

						pageCursor = db.rawQuery("SELECT * FROM "
								+ DispMgrUtility.CURRENT_INDEX_TABLE
								+ " WHERE PageNo == " + (this.miDmbPageNo)
								+ ";", null);

					}

					pageCursor.moveToFirst();
					break;
				}

			}

		}

		/* if xmllevel not null */
		if (null != pageCursor.getString(pageCursor.getColumnIndex("XmlLevel"))) {
			/* clear the memory */
			epubparser.XHTML_Deinit();
			/* get the chapter number */
			this.miDmbCurrentChapter = pageCursor.getInt(1) - 1;
		}
		/* set line buffer status */
		this.miDmbLineBufferStatus = utl.EBOOK_FALSE;
		/* set book status */
		this.miDmbBookStatus = utl.EBOOK_TRUE;
		/* get page number */

		this.miDmbPageNo = pageCursor.getInt(0);

		/* set pre content */
		this.miDmbPreContent = utl.XHTML_TAG_ELEMENT_COUNT;
		/* set xmllevel */
		this.msDmbXmlLevl = pageCursor.getString(2);
		/* get line number */
		this.miDmbLineNo = pageCursor.getInt(3);
		/* get zoome level */
		this.mfDmbZoomLevel = pageCursor.getFloat(4);
		/* close the cursor */
		pageCursor.close();
		return 0;

	}

	/*
	 * To get the data for the specific chapter from data base
	 */
	int mdisplayManagerGetChapterInfo(SQLiteDatabase db, int chnum) {
		// loop until the index table generates the particular chapter index
		// while (true) {
		/* fetch the max of chapter number */
		Cursor tempcursor = db.rawQuery("SELECT MAX(ChapterNo) FROM "
				+ DispMgrUtility.INDEX_TABLE + ";", null);
		/* move the cursor to first position */
		tempcursor.moveToFirst();
		/* check the max chapter is less than requried chapter */
		if (tempcursor.getInt(0) < chnum) {
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			/* close cursor */
			tempcursor.close();
			// continue;
		}
		// after finding the chapter index from the index table
		else {
			try {
				/* acquire semaphore */
				Display_Manager.mSemaphore.acquire();
				/* set page flag for normal page operation */
				this.mObjDifFlag = Display_Manager.PAGE_NAVIGATION_START;
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			/* fetch first page of the chapter */
			Cursor chapterCursor = db.rawQuery("SELECT * FROM "
					+ DispMgrUtility.INDEX_TABLE + " WHERE ChapterNo = "
					+ chnum + " order by PageNo asc ;", null);
			/* move the cursor to first position */
			chapterCursor.moveToFirst();
			/* if xmllevel not null */
			if (null != chapterCursor.getString(chapterCursor
					.getColumnIndex("XmlLevel"))) {
				/* free the memory */
				this.epubparser.XHTML_Deinit();
				/* get the chapter number */
				this.miDmbCurrentChapter = chapterCursor.getInt(1) - 1;
			}
			/* set line buffer status */
			this.miDmbLineBufferStatus = utl.EBOOK_FALSE;
			/* get page number */
			this.miDmbPageNo = chapterCursor.getInt(0);
			/* set pre content */
			this.miDmbPreContent = utl.XHTML_TAG_ELEMENT_COUNT;
			/* get xml level */
			this.msDmbXmlLevl = chapterCursor.getString(2);
			/* get line number */
			this.miDmbLineNo = chapterCursor.getInt(3);
			/* get zoom level */
			this.mfDmbZoomLevel = chapterCursor.getFloat(4);
			/* close cursor */
			chapterCursor.close();

		}
		// }
		return 0;
	}

	/*
	 * getting the data from .epub file by using EPUBparser.so(native methods)
	 */
	int mDisplayManagerGetData() {
		int iRetVal = 0;
		iRetVal = utl.DISPMGR_SUCCESS;
		while (true) {
			/*
			 * If Doc pointer is NULL or endof the file reached return proper
			 * return value
			 */

			if (this.mFasterTOc == 0) {
				iRetVal = epubparser.XHTML_GetNextField(
						epubparser.xhtmlfieldparam, this.msDmbXmlLevl,
						mObjDifFlag,this.BypassgetnextField);
				if(this.BypassgetnextField == 1)
				{
					this.BypassgetnextField=0;
				}
				
				
				 //Call to the native code to get CSS parser Values
				 
				//Log.e("MAK ITS before1 ", "CssPropInfo");
				epubparser.CssProp = epubparser.CssPropInfo();
				//Log.e("MAK ITS After1 ", "CssPropInfo");

				/*Test Code For CSS values*/
				if(this.mObjDifFlag == 1){
				int n = epubparser.getCsscount();
				
				/*for(int i=0;i<n;i++)
				{
					Log.e("MAK After GetFirstField", " = "+epubparser.getenpropty(i));
					Log.e("MAK After GetFirstField", " = "+epubparser.getvalue(i));
					Log.e("MAK After GetFirstField", " = "+epubparser.getenunit(i));
					
				}*/
				}
				
				
				
				
			} else {
				iRetVal = -7;

				this.mFasterTOc = 0;
			}

			if (iRetVal < utl.DISPMGR_SUCCESS) {
				/*
				 * If End of chapter occurs in the middle of the page then break
				 * else continue
				 */
				if (miDmbViewYpos != 0) {
					if (this.miDmbTotalChapter > miDmbCurrentChapter) {
						return utl.DISPMGR_EOFPAGE;
					} else {
						miDmbBookStatus = utl.DISPMGR_ENDOFBOOK;
						return utl.DISPMGR_ENDOFBOOK;
					}

				}
				/* Check for end of book. */
				if (this.miDmbTotalChapter > miDmbCurrentChapter) {
					if (this.miDmbBookStart == utl.EBOOK_TRUE) {
						/* free the memory */
						epubparser.XHTML_Deinit();
					} else {
						this.miDmbBookStart = utl.EBOOK_TRUE;
					}
					/* increase the chapter index */
					this.miDmbCurrentChapter++;
					if (Display_Manager.ResetPageNumForTOC == 1) {
						this.miDmbPageNo = 1;
						Display_Manager.ResetPageNumForTOC = 0;
					}

					iRetVal = mDispInitChapter();
					if (iRetVal < utl.DISPMGR_SUCCESS) {
						return utl.DISPMGR_FAILURE;
					}

				} else {
					this.miDmbBookStatus = utl.DISPMGR_ENDOFBOOK;
					return utl.DISPMGR_ENDOFBOOK;
				}
			}
			break;
		}
		// Added for proto 3 Annotation

		if (epubparser.getContent() != null) {

			{
				if (rawbufferptr != null) {
					rawbufferptr += epubparser.getContent();
				}

			}
		}
		iRetVal = mDisplayManagerGetReflowBuffer();
		return iRetVal;

	}

	/*
	 * To initialize the chapter
	 */
	int mDispInitChapter() {
		String ChapterName = null;
		int RetVal;
		String OPFDir = null;
		/* get the OPF file directory */
		OPFDir = epubparser.CP_GetOpfDir(epubparser.CP_GetOpfPath(
				epubparser.cproot, epubparser.cprootfile));
		/* get the chapter name */
		ChapterName = epubparser.OPF_GetFilename(epubparser.objMetadata,
				miDmbCurrentChapter - 1, epubparser.aspineelement,
				epubparser.amanifestelement);
		/* if chapter name is null */
		if (ChapterName == null) {
			return utl.DISPMGR_FAILURE;
		}
		/* if OPF directory is not null append chapter name to directory */
		if ((OPFDir != null)) {
			OPFDir = OPFDir + "/" + ChapterName;
		}
		/* if OPF directory is null assign OPF directory to chapter name */
		else {
			OPFDir = ChapterName;
		}

		/* To initialize XHTML parser */
		RetVal = epubparser.EPUB_AL_InitXhtmlFile(msDmbBookName, OPFDir,
				epubparser.xhtmlfieldparam, mObjDifFlag);

		if (RetVal < utl.DISPMGR_SUCCESS) {
			return utl.DISPMGR_FAILURE;
		}
		/* To get the first paragraph */
		RetVal = epubparser.XHTML_GetFirstField(epubparser.xhtmlfieldparam,
				msDmbXmlLevl, mObjDifFlag);
		 //Call to the native code to get CSS parser Values
		 
		//Log.e("MAK ITS before2 ", "CssPropInfo");
		epubparser.CssProp = epubparser.CssPropInfo();
		//Log.e("MAK ITS After2 ", "CssPropInfo");
		
		/*Test Code For CSS values*/
		if(this.mObjDifFlag == 1){
		int n = epubparser.getCsscount();
		
		
		}
		
		
		
		return (RetVal >= utl.DISPMGR_SUCCESS ? utl.DISPMGR_SUCCESS
				: utl.DISPMGR_FAILURE);
	}

	/*
	 * Get the data and use the linebreak algorithm to reflow the data
	 */
	int mDisplayManagerGetReflowBuffer() {
		DispMgrLineBreakInfo linebrkinput = new DispMgrLineBreakInfo();
		DispMgrReflow stReflowParam = new DispMgrReflow();
		linebreak lnbrk = new linebreak();
		String Break = null;
		int Retval;
		/* if a content type is not a image */
		if (epubparser.getContentType() != utl.XHTML_IMAGE) {
			/* get the length of content */
			linebrkinput.miLbLen = epubparser.getContentSize();
			/* get the content */
			linebrkinput.msLbInBuffer = epubparser.getContent();
			/* allocate the memory to hold the break points */
			linebrkinput.mbLbBreakpoints = new byte[linebrkinput.msLbInBuffer
					.length()];
			/* if memory not allocated */
			if (linebrkinput.mbLbBreakpoints == null) {
				return utl.DISPMGR_FAILURE;
			}
			/* Apply line break algorithem */
			lnbrk.linebreaks(linebrkinput.msLbInBuffer,
					linebrkinput.mbLbBreakpoints);
		}
		/* sets the default page layout */
		this.mDmPageStyleInfo
				.display_manager_SetDefaultPageLayout(this.epubparser);
		/* if its not contains bullet and numbering */
		if ((epubparser.getContentType() != utl.XHTML_ORDERED_LIST)
				&& (epubparser.getContentType() != utl.XHTML_UNORDERED_LIST)) {
			
			mDmPageStyleInfo.DISPLAYOUT_GetPageLayout(epubparser);
			
		}
		/* if content type is not an image */
		if (epubparser.getContentType() != utl.XHTML_IMAGE) {
			/* start x position to a paragraph */
			stReflowParam.miRfLineStartX = this.mDmPageStyleInfo.miPgstLeftMargin;
			/* left margin of paragraph */
			stReflowParam.miRfLineX = this.mDmPageStyleInfo.miPgstLeftMargin;
			/* right margin of paragraph */
			stReflowParam.miRfRightMargin = this.mDmPageStyleInfo.miPgstRightMargin;
			/* font size of paragraph */
			stReflowParam.mfRfFontSize = this.mDmPageStyleInfo.mfPgstFontSize;
			/* font style of paragraph */
			stReflowParam.miRfFontStyle = this.mDmPageStyleInfo.miPgstFontStyle;
			/* font family of paragraph */
			stReflowParam.msRfFontFamily = this.mDmPageStyleInfo.msPgstFontFamily;
			/* font weight of paragraph */
			stReflowParam.mRfFontWeight = this.mDmPageStyleInfo.mPgstFontWeight;
			/* Apply reflow */
			Retval = mDisplayManagerApplyReflow(stReflowParam, linebrkinput);
			if (Retval < utl.DISPMGR_SUCCESS) {
				return Retval;
			}
		}
		return utl.DISPMGR_SUCCESS;

	}

	/*
	 * Apply the reflow on the data according to the out put of linebreak
	 */
	int mDisplayManagerApplyReflow(DispMgrReflow reflow,
			DispMgrLineBreakInfo linebreak) {
		String TempChar = null;
		String TempData = null;
		String BreakData = null;
		int BufferEnd = 0;
		int LastBreakPos = 0;
		int LastBreakablePos = 0;
		int NewLineCount = 0;
		float CharWidth = 0;
		int LineWidth = 0;
		int i = 0;
		int j = 0;
		int Col = 0;
		/* width of line */
		LineWidth = reflow.miRfRightMargin - reflow.miRfLineStartX;
		Paint pen = new Paint();
		/* set the font size */
		pen.setTextSize(reflow.mfRfFontSize * this.mfDmbZoomLevel);
		/* set type fase */
		pen.setTypeface(Typeface.SERIF);
		linebreak l1 = new linebreak();
		/*
		 * check character by character to apply the break information according
		 * to page height and width
		 */
		for (i = 0; i < linebreak.msLbInBuffer.length(); ++i) {
			if (linebreak.mbLbBreakpoints[i] == l1.MUSTBREAK) {
				/* find breakable positions */
				for (j = LastBreakPos; j <= i; ++j) {
					if (TempData == null) {
						TempData = linebreak.msLbInBuffer.substring(j, j + 1);
						BufferEnd++;
					} else {
						TempData = TempData.substring(0, BufferEnd++)
								+ linebreak.msLbInBuffer.charAt(j);
					}
				}
				/* if buffer end not contain \n append \n */
				if (TempData.charAt(BufferEnd - 1) != '\n') {
					TempData = TempData.substring(0, BufferEnd++) + '\n';

				}
				/* increment line count */
				NewLineCount++;
				/* Update positions */
				Col = 0;
				LastBreakPos = LastBreakablePos = i + 1;
				continue;
			}
			/* get one character from string */
			TempChar = linebreak.msLbInBuffer.substring(i, i + 1);
			/* get the character width */
			CharWidth = pen.measureText(TempChar, 0, 1);
			/*
			 * if character is not a space and the line width is not reached
			 * then increse the line width
			 */
			if (!((TempChar.charAt(0) == SPACE) && (Col == LineWidth))) {
				Col += Math.ceil(CharWidth);
			}
			if (Col <= LineWidth) {
				if (linebreak.mbLbBreakpoints[i] == l1.ALLOWBREAK) {
					LastBreakablePos = i + 1;
				}
			}
			/* Right margin crossed */
			else {
				/* No breakable character since the last break */
				if (LastBreakablePos == LastBreakPos) {
					LastBreakablePos = i;
				} else {
					i = LastBreakablePos;
				}
				CharWidth = 0;
				for (j = LastBreakPos; j < i; ++j) {
					if (TempData == null) {
						TempData = linebreak.msLbInBuffer.substring(j, j + 1);
						BufferEnd++;
						TempChar = linebreak.msLbInBuffer.substring(j, j + 1);
						CharWidth += pen.measureText(TempChar, 0, 1);
					} else {
						TempData = TempData.substring(0, BufferEnd++)
								+ linebreak.msLbInBuffer.charAt(j);

						TempChar = linebreak.msLbInBuffer.substring(j, j + 1);
						CharWidth += pen.measureText(TempChar, 0, 1);
					}

				}
				if (CharWidth > LineWidth) {
					BufferEnd--;
				}
				TempData = TempData.substring(0, BufferEnd++) + '\n';
				NewLineCount++;

				/* Output a new line and reset status */
				LastBreakPos = LastBreakablePos;
				Col = 0;

				--i;
			}
			if (NewLineCount == 1) {
				// for testing
				LineWidth = reflow.miRfRightMargin - reflow.miRfLineX;
			}
		}
		// BufferLength = BufferEnd;
		miDmbLineCount = NewLineCount;
		if (null != linebreak.msLbInBuffer) {

			linebreak.msLbInBuffer = null;
		}
		if (TempData != null) {
			// copy TempData to databuffer
			epubparser.setContent(TempData.substring(0, TempData.length()));
			return 1;
		}

		else {
			return 0;
		}

	}

	/*
	 * get the image path to be displayed
	 */
	String mDispMgrLoadImage() {

		String ImageFile = epubparser.getHref();
		String ImageOPFDir = null;
		String Imagepath = null;
		/* Get OPF path */
		String opffilepath = epubparser.CP_GetOpfPath(epubparser.cproot,
				epubparser.cprootfile);
		/* get OPF directory */
		ImageOPFDir = epubparser.CP_GetOpfDir(opffilepath);
		/* construct the image path */
		if (ImageOPFDir != null) {
			ImageOPFDir += "/" + ImageFile;
		} else {
			ImageOPFDir = ImageFile;
		}
		/* if book name is not null */
		if (msDmbBookName != null) {
			/* extract the Image from the OPF directory */
			Imagepath = epubparser
					.UTILS_ExtractFile(msDmbBookName, ImageOPFDir);
		}
		return Imagepath;

	}

	public String mResetXmllevelForZoom(SQLiteDatabase db, int CurrentChapter,
			int pagenum) {
		Cursor tempcursor = null;
		tempcursor = db.rawQuery("SELECT XmlLevel FROM "
				+ DispMgrUtility.INDEX_TABLE + " WHERE PageNo = 1 ;", null);
		/* move the cursor to first position */
		tempcursor.moveToFirst();
		String str = tempcursor.getString(0);
		return str;
	}

	// Added for Proto3 Annotation

	public class XmlLevel_param {
		int Total_lines; /* Total lines in that xml level */
		int StartXpos; /* Start Xpos of that xml level */
		int StartYpos; /* Start Ypos of that xml level */
		int EndXpos; /* End Xpos of that xml level */
		int EndYpos; /* End Ypos of that xml level */
		int FontSize; /* Font Size of that Xml Level */
		int LineSpace; /* Line Spacing between two lines */
		int totalstrlen; /*
						 * Total string length of all the lines in that xml
						 * level
						 */
		int Strlen_eachline[]; /* Stores the string length of each line */
		int ParaOffset; /* Para Offset */
		int LeftMargin; /* Left Margin */
		// DISPMGR_FONT_EN enFontType; /*Font used for that xml level*/
		double ZoomLevel; /* Zoom level */
		int XmlLvlProLineCnt; /*
							 * No of lines processed for that xml level in that
							 * page
							 */
		int LineBufferStatusFlag; /*
								 * Flag to indicate if the xml level displayed
								 * is from old buffer
								 */
		int PrevLineProcessed; /*
								 * No of lines displayed for the continued
								 * buffer in the prev ious page
								 */
		String aui8xmllvl;
	}

	String rawbufferptr; /* Points to the start of the page */
	int mXmlLevelCount;
}
